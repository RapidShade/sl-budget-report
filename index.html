<!DOCTYPE html>
<html>
<head>
    <title>Event PDF Budget Report Widget</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: #f8f8f8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            box-sizing: border-box;
            text-align: center;
        }
        .container {
            text-align: left;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
        }
        h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        p {
            font-size: 1em;
            color: #666;
            margin-bottom: 25px;
            text-align: center;
        }
        .button-container {
            text-align: center;
            width: 100%;
        }
        button {
            background-color: #4CAF50; /* Grist-like green */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        #record-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #555;
            min-height: 20px; /* To prevent layout shift */
            text-align: center;
        }
        .error-message {
            color: red;
            background-color: #ffe0e0;
            border: 1px solid red;
            padding: 10px;
            margin-top: 20px;
            border-radius: 5px;
        }
        #report-container {
            margin-top: 30px;
            text-align: left;
        }
        .event-details {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }
        .event-details h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        .event-details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
        }
        .detail-item {
            font-size: 0.95em;
        }
        .detail-item strong {
            color: #495057;
        }
        .expense-group {
            margin-bottom: 20px;
        }
        .expense-group h3 {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            color: #495057;
            margin: 0 0 10px 0;
        }
        .expense-item, .group-summary {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid #dee2e6;
        }
        .group-summary {
            font-weight: bold;
            background-color: #f8f9fa;
            border-top: 2px solid #dee2e6;
            margin-top: 5px;
        }
        .grand-total {
            display: flex;
            justify-content: space-between;
            padding: 12px 10px;
            margin-top: 20px;
            background-color: #2c3e50;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
            border-radius: 4px;
        }
        .expense-item:last-child {
            border-bottom: none;
        }
    </style>
    <!-- pdf-lib and fontkit libraries for PDF generation -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit/dist/fontkit.umd.min.js"></script>
    <!-- Grist Plugin API -->
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
</head>
<body>
    <div class="container" id="widget-container">
        <h2>Event PDF Budget Report</h2>
        <p id="message">Connecting to Grist... Please select an event record.</p>
        <div class="button-container">
            <button id="downloadPdfButton" style="display: none;" disabled>Download PDF Report</button>
        </div>
        <div id="record-info"></div>
        <div id="report-container"></div>
    </div>

    <script>
        console.log("[WIDGET] v7.1 Starting");

        // Ensure PDF libraries are loaded
        if (typeof PDFLib === 'undefined' || typeof fontkit === 'undefined') {
            document.getElementById('widget-container').innerHTML = '<div class="error-message">Error: PDF Libraries not loaded. Please check your internet connection.</div>';
            throw new Error("PDF-Lib or fontkit not found.");
        }

        const { PDFDocument, rgb } = PDFLib;
        const messageElement = document.getElementById('message');
        const downloadPdfButton = document.getElementById('downloadPdfButton');
        const recordInfoElement = document.getElementById('record-info');
        const reportContainer = document.getElementById('report-container');

        let currentRecord = null;
        let allExpenses = [];
        let allExpenseCategories = [];

        // Helper to format currency
        const formatCurrency = (amount) => (amount || 0).toLocaleString('el-GR', { style: 'currency', currency: 'EUR' });

        // Helper to convert Grist's column-based table data to an array of record objects
        function tableToRecords(data) {
            if (!data || typeof data !== 'object' || Array.isArray(data)) {
                return Array.isArray(data) ? data : [];
            }
            const columns = Object.keys(data);
            if (columns.length === 0 || !Array.isArray(data[columns[0]])) {
                return [];
            }
            const numRows = data[columns[0]].length;
            const records = [];
            for (let i = 0; i < numRows; i++) {
                const record = {};
                for (const column of columns) {
                    record[column] = data[column][i];
                }
                records.push(record);
            }
            return records;
        }

        // Main function to fetch all necessary data from Grist
        async function fetchData() {
            try {
                // Corrected table names as per your description
                const rawExpenses = await grist.docApi.fetchTable('Expenses');
                const rawCategories = await grist.docApi.fetchTable('ExpenseCategories');
                
                allExpenses = tableToRecords(rawExpenses);
                allExpenseCategories = tableToRecords(rawCategories);
                console.log("Fetched Expenses:", allExpenses);
                console.log("Fetched Expense Categories:", allExpenseCategories);
            } catch (error) {
                console.error("Error fetching data:", error);
                reportContainer.innerHTML = `<div class="error-message">Error fetching data. Check table names ('Expenses', 'ExpenseCategories') and ensure the widget has 'full' access.</div>`;
            }
        }

        // Renders the report in HTML for on-screen preview
        function renderHtmlReport() {
            reportContainer.innerHTML = ''; // Clear previous report
            if (!currentRecord || !allExpenses.length || !allExpenseCategories.length) {
                return;
            }

            // Render Event Details Section
            const eventDetailsDiv = document.createElement('div');
            eventDetailsDiv.className = 'event-details';
            eventDetailsDiv.innerHTML = `
                <h3>Event Details</h3>
                <div class="event-details-grid">
                    <div class="detail-item"><strong>Event:</strong> ${currentRecord.Name || 'N/A'}</div>
                    <div class="detail-item"><strong>Sport:</strong> ${currentRecord.Sport_text || 'N/A'}</div>
                    <div class="detail-item"><strong>Dates:</strong> ${formatDate(currentRecord.DateStart)} to ${formatDate(currentRecord.DateEnd)}</div>
                    <div class="detail-item"><strong>Location:</strong> ${currentRecord.CITY || 'N/A'}, ${currentRecord.VENUE || 'N/A'}</div>
                    <div class="detail-item"><strong>Level:</strong> ${currentRecord.LEVEL || 'N/A'}</div>
                </div>
            `;
            reportContainer.appendChild(eventDetailsDiv);

            // Filter expenses for the selected event
            const eventExpenses = allExpenses.filter(e => e.Event === currentRecord.id);
            const categoryMap = new Map(allExpenseCategories.map(c => [c.id, c]));
            let grandTotal = 0;

            // Group expenses by category
            const groupedExpenses = eventExpenses.reduce((acc, detail) => {
                const category = categoryMap.get(detail.ExpenseCategory);
                if (category) {
                    // Use GroupName for grouping, fallback to Name
                    const groupName = category.GroupName || category.Name || 'Uncategorized';
                    if (!acc[groupName]) {
                        acc[groupName] = {
                            items: [],
                            displayOrder: category.DisplayOrder || 999,
                            total: 0
                        };
                    }
                    acc[groupName].items.push({
                        description: detail.LineDescription,
                        amount: detail.Amount
                    });
                    acc[groupName].total += detail.Amount || 0;
                }
                return acc;
            }, {});

            // Sort groups based on DisplayOrder
            const sortedGroups = Object.entries(groupedExpenses).sort(([, a], [, b]) => a.displayOrder - b.displayOrder);

            // Render each group
            for (const [groupName, groupData] of sortedGroups) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'expense-group';
                
                const title = document.createElement('h3');
                title.textContent = groupName;
                groupDiv.appendChild(title);

                for (const item of groupData.items) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'expense-item';
                    itemDiv.innerHTML = `<span>${item.description || ''}</span><span>${formatCurrency(item.amount)}</span>`;
                    groupDiv.appendChild(itemDiv);
                }

                // Render group summary
                const summaryDiv = document.createElement('div');
                summaryDiv.className = 'group-summary';
                summaryDiv.innerHTML = `<span>Group Total</span><span>${formatCurrency(groupData.total)}</span>`;
                groupDiv.appendChild(summaryDiv);
                
                reportContainer.appendChild(groupDiv);
                grandTotal += groupData.total;
            }

            // Render Grand Total
            const grandTotalDiv = document.createElement('div');
            grandTotalDiv.className = 'grand-total';
            grandTotalDiv.innerHTML = `<span>GRAND TOTAL</span><span>${formatCurrency(grandTotal)}</span>`;
            reportContainer.appendChild(grandTotalDiv);
        }

        // Function to handle Grist record selection
        async function onRecordUpdate(record, mappings) {
            currentRecord = record;
            if (record && Object.keys(record).length > 0) {
                console.log("[WIDGET] Record selected:", record);
                messageElement.style.display = 'none';
                downloadPdfButton.style.display = 'inline-block';
                downloadPdfButton.disabled = false;
                recordInfoElement.textContent = `Selected: ${record.Name || record.EventCode || 'Unnamed Event'}`;
                renderHtmlReport(); // Render the HTML preview
            } else {
                console.log("[WIDGET] No record selected.");
                currentRecord = null;
                messageElement.style.display = 'block';
                messageElement.textContent = "Please select a record in the Events table.";
                downloadPdfButton.style.display = 'none';
                downloadPdfButton.disabled = true;
                recordInfoElement.textContent = '';
                reportContainer.innerHTML = '';
            }
        }

        // Helper to format dates
        function formatDate(dateInput) {
            if (!dateInput) return 'N/A';
            // Grist sends dates as seconds since epoch
            const date = new Date(dateInput * 1000);
            if (isNaN(date.getTime())) return 'Invalid Date';
            return date.toLocaleDateString('el-GR'); // Format as DD/MM/YYYY
        }

        // The main PDF generation logic
        async function generatePdfReport() {
            if (!currentRecord) {
                alert("Please select a record first.");
                return;
            }

            downloadPdfButton.disabled = true;
            downloadPdfButton.textContent = 'Generating...';

            try {
                // --- FONT LOADING ---
                // Fetch the font files for UTF-8 support (including Greek characters)
                const fontUrl = 'https://pdf-lib.js.org/assets/ubuntu/Ubuntu-R.ttf';
                const boldFontUrl = 'https://pdf-lib.js.org/assets/ubuntu/Ubuntu-B.ttf';

                const [fontBytes, boldFontBytes] = await Promise.all([
                    fetch(fontUrl).then(res => res.arrayBuffer()),
                    fetch(boldFontUrl).then(res => res.arrayBuffer())
                ]);
                
                // Create a new PDF document
                const pdfDoc = await PDFDocument.create();
                
                // Register fontkit to handle the custom font
                pdfDoc.registerFontkit(fontkit);

                // Embed the custom fonts
                const customFont = await pdfDoc.embedFont(fontBytes);
                const customBoldFont = await pdfDoc.embedFont(boldFontBytes);

                let page = pdfDoc.addPage();
                const { width, height } = page.getSize();

                let y = height - 50;
                const x = 50;
                const rightMargin = width - 50;

                // --- PDF Header ---
                page.drawText('Event Budget Report', { x, y, font: customBoldFont, size: 18, color: rgb(0, 0, 0) });
                y -= 30;

                // --- Event Details Section ---
                const eventDetails = [
                    { label: 'Event', value: currentRecord.Name || 'N/A' },
                    { label: 'Sport', value: currentRecord.Sport_text || 'N/A' },
                    { label: 'Dates', value: `${formatDate(currentRecord.DateStart)} to ${formatDate(currentRecord.DateEnd)}` },
                    { label: 'Location', value: `${currentRecord.CITY || 'N/A'}, ${currentRecord.VENUE || 'N/A'}` },
                    { label: 'Level', value: currentRecord.LEVEL || 'N/A' },
                ];
                
                for(const detail of eventDetails) {
                    page.drawText(`${detail.label}:`, { x, y, font: customBoldFont, size: 10 });
                    page.drawText(String(detail.value), { x: x + 80, y, font: customFont, size: 10 });
                    y -= 15;
                }
                y -= 20; // Extra space after header

                // --- Process and Draw Expenses ---
                const eventExpenses = allExpenses.filter(e => e.Event === currentRecord.id);
                const categoryMap = new Map(allExpenseCategories.map(c => [c.id, c]));
                let grandTotal = 0;

                const groupedExpenses = eventExpenses.reduce((acc, detail) => {
                    const category = categoryMap.get(detail.ExpenseCategory);
                    if (category) {
                        const groupName = category.GroupName || category.Name || 'Uncategorized';
                        if (!acc[groupName]) {
                            acc[groupName] = { items: [], displayOrder: category.DisplayOrder || 999, total: 0 };
                        }
                        acc[groupName].items.push({ description: detail.LineDescription, amount: detail.Amount });
                        acc[groupName].total += detail.Amount || 0;
                    }
                    return acc;
                }, {});

                const sortedGroups = Object.entries(groupedExpenses).sort(([, a], [, b]) => a.displayOrder - b.displayOrder);

                for (const [groupName, groupData] of sortedGroups) {
                    // Add new page if not enough space
                    if (y < 80) { 
                        page = pdfDoc.addPage();
                        y = height - 50;
                    }

                    // Group Header
                    page.drawText(groupName, { x, y, font: customBoldFont, size: 12, color: rgb(0.1, 0.1, 0.1) });
                    y -= 20;

                    // Group Items
                    for (const item of groupData.items) {
                        if (y < 40) {
                             page = pdfDoc.addPage();
                             y = height - 50;
                        }
                        page.drawText(String(item.description || ''), { x: x + 10, y, font: customFont, size: 10 });
                        const amountText = formatCurrency(item.amount);
                        const textWidth = customFont.widthOfTextAtSize(amountText, 10);
                        page.drawText(amountText, { x: rightMargin - textWidth, y, font: customFont, size: 10 });
                        y -= 15;
                    }

                    // Group Summary
                    const summaryText = formatCurrency(groupData.total);
                    const summaryWidth = customBoldFont.widthOfTextAtSize(summaryText, 10);
                    page.drawText('Group Total:', { x: rightMargin - summaryWidth - 70, y, font: customBoldFont, size: 10 });
                    page.drawText(summaryText, { x: rightMargin - summaryWidth, y, font: customBoldFont, size: 10 });
                    y -= 25; // Extra space after group
                    
                    grandTotal += groupData.total;
                }
                
                // --- Grand Total ---
                if (y < 50) {
                    page = pdfDoc.addPage();
                    y = height - 50;
                }
                const grandTotalText = `GRAND TOTAL: ${formatCurrency(grandTotal)}`;
                const grandTotalWidth = customBoldFont.widthOfTextAtSize(grandTotalText, 14);
                page.drawText(grandTotalText, { x: rightMargin - grandTotalWidth, y, font: customBoldFont, size: 14, color: rgb(0, 0, 0) });

                // --- Save and Download PDF ---
                const pdfBytes = await pdfDoc.save();
                const filename = `Budget_Report_${(currentRecord.Name || 'Event').replace(/ /g, '_')}.pdf`;
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

            } catch (error) {
                console.error("[WIDGET] Error generating PDF:", error);
                recordInfoElement.textContent = 'Error creating PDF. Check console for details.';
            } finally {
                downloadPdfButton.disabled = false;
                downloadPdfButton.textContent = 'Download PDF Report';
            }
        }
        
        // --- Initialization ---
        grist.ready({
            requiredAccess: 'full',
            // Define the columns from the 'Events' table that the widget needs.
            // This makes the data available in the 'record' object.
            columns: [
                'EventCode', 'Name', 'Sport', 'Discipline', 'DateStart', 'DateEnd',
                'PERIF_CITY', 'CITY', 'VENUE', 'LEVEL', 'POOL_SIZE', 'Organiser',
                // Add reference column text representations if available, e.g., Sport_text
                {name: 'Sport', optional: true},
                {name: 'Sport_text', optional: true} // Example if you have a formula column
            ]
        });

        // Fetch data once when the widget is ready
        fetchData(); 

        // Listen for record changes
        grist.onRecord(onRecordUpdate);

        // Add event listener for the download button
        downloadPdfButton.addEventListener('click', generatePdfReport);

    </script>
</body>
</html>
